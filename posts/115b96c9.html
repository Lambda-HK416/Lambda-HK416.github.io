<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Linux系统编程学习 | Lambda🍃</title><meta name="keywords" content="Linux,远程开发,C/C++,系统调用"><meta name="author" content="Lambda"><meta name="copyright" content="Lambda"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="常用头文件    头文件 作用     &lt;stdio.h&gt; 标准输入输出库函数的声明，包括 printf、scanf、fopen 等。   &lt;stdlib.h&gt; 提供通用的工具函数，如动态内存分配 (malloc)、进程控制 (exit) 等。   &lt;string.h&gt; 字符串操作函数的声明，如 strlen、strcpy、strcmp 等。   &lt;mat"><meta property="og:type" content="article"><meta property="og:title" content="Linux系统编程学习"><meta property="og:url" content="https://www.wikunkun.asia/posts/115b96c9.html"><meta property="og:site_name" content="Lambda🍃"><meta property="og:description" content="常用头文件    头文件 作用     &lt;stdio.h&gt; 标准输入输出库函数的声明，包括 printf、scanf、fopen 等。   &lt;stdlib.h&gt; 提供通用的工具函数，如动态内存分配 (malloc)、进程控制 (exit) 等。   &lt;string.h&gt; 字符串操作函数的声明，如 strlen、strcpy、strcmp 等。   &lt;mat"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://lambda-image-1.pages.dev/20250117161208658.webp"><meta property="article:published_time" content="2025-01-12T19:27:14.000Z"><meta property="article:modified_time" content="2025-02-13T10:47:20.313Z"><meta property="article:author" content="Lambda"><meta property="article:tag" content="Linux"><meta property="article:tag" content="远程开发"><meta property="article:tag" content="C&#x2F;C++"><meta property="article:tag" content="系统调用"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lambda-image-1.pages.dev/20250117161208658.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://www.wikunkun.asia/posts/115b96c9"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="codeva-rzTOSH8WUb"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:30,position:"top",messagePrev:"距上次更新时间已经过了",messageNext:"天，文章内容可能已过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:230},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Linux系统编程学习",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-02-13 18:47:20"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><script src="https://npm.elemecdn.com/echarts@4.9.0/map/js/china.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/todolist/todolist.css"><link rel="stylesheet" href="/css/contact-info/contact-info.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><link rel="stylesheet" href="https://ai.tianli0.top/static/public/tianli_gpt.min.css"><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lambda🍃" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/avatar.jpg" onerror='onerror=null,src="/assets/r1.jpg"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xiangzi"></use></svg> <span class="menu_word" style="font-size:17px">工具箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-tubiaozhizuomoban"></use></svg> <span class="menu_word" style="font-size:17px">画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-zhifengche"></use></svg> <span class="menu_word" style="font-size:17px">网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/todolist/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shengdanqiu"></use></svg> <span class="menu_word" style="font-size:17px">计划</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-wangye"></use></svg> <span class="menu_word" style="font-size:17px">网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shujutongji1"></use></svg> <span class="menu_word" style="font-size:17px">文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xianxingshalou"></use></svg> <span class="menu_word" style="font-size:17px">旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-paperplane"></use></svg> <span class="menu_word" style="font-size:17px">关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lambda🍃</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xiangzi"></use></svg> <span class="menu_word" style="font-size:17px">工具箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-tubiaozhizuomoban"></use></svg> <span class="menu_word" style="font-size:17px">画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-zhifengche"></use></svg> <span class="menu_word" style="font-size:17px">网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/todolist/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shengdanqiu"></use></svg> <span class="menu_word" style="font-size:17px">计划</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-wangye"></use></svg> <span class="menu_word" style="font-size:17px">网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shujutongji1"></use></svg> <span class="menu_word" style="font-size:17px">文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xianxingshalou"></use></svg> <span class="menu_word" style="font-size:17px">旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-paperplane"></use></svg> <span class="menu_word" style="font-size:17px">关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg> <span>搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux系统编程学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span> <time class="post-meta-date-created" datetime="2025-01-12T19:27:14.000Z" title="发表于 2025-01-13 03:27:14">2025-01-13</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-13T10:47:20.313Z" title="更新于 2025-02-13 18:47:20">2025-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">1.3w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Linux系统编程学习"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="常用头文件"><a href="#常用头文件" class="headerlink" title="常用头文件"></a>常用头文件</h2><div class="table-container"><table><thead><tr><th>头文件</th><th>作用</th></tr></thead><tbody><tr><td><strong><code>&lt;stdio.h&gt;</code></strong></td><td>标准输入输出库函数的声明，包括 <code>printf</code>、<code>scanf</code>、<code>fopen</code> 等。</td></tr><tr><td><strong><code>&lt;stdlib.h&gt;</code></strong></td><td>提供通用的工具函数，如动态内存分配 (<code>malloc</code>)、进程控制 (<code>exit</code>) 等。</td></tr><tr><td><strong><code>&lt;string.h&gt;</code></strong></td><td>字符串操作函数的声明，如 <code>strlen</code>、<code>strcpy</code>、<code>strcmp</code> 等。</td></tr><tr><td><strong><code>&lt;math.h&gt;</code></strong></td><td>提供数学计算函数的声明，如 <code>sin</code>、<code>cos</code>、<code>sqrt</code> 等。</td></tr><tr><td><strong><code>&lt;time.h&gt;</code></strong></td><td>时间和日期操作函数的声明，如 <code>time</code>、<code>localtime</code>、<code>strftime</code> 等。</td></tr><tr><td><strong><code>&lt;unistd.h&gt;</code></strong></td><td>定义 POSIX 标准的 API，如文件操作（<code>read</code>、<code>write</code>）、进程管理等。</td></tr><tr><td><strong><code>&lt;fcntl.h&gt;</code></strong></td><td>文件控制相关函数和常量的声明，如 <code>open</code>、文件访问模式常量等。</td></tr><tr><td><strong><code>&lt;sys/types.h&gt;</code></strong></td><td>定义数据类型，如 <code>pid_t</code>、<code>uid_t</code>、<code>gid_t</code> 等，用于系统调用。</td></tr><tr><td><strong><code>&lt;sys/stat.h&gt;</code></strong></td><td>文件状态操作函数的声明，如 <code>stat</code>、<code>chmod</code>、<code>mkdir</code> 等。</td></tr><tr><td><strong><code>&lt;errno.h&gt;</code></strong></td><td>定义全局错误变量 <code>errno</code> 及错误码常量，如 <code>EACCES</code>、<code>ENOENT</code> 等。</td></tr><tr><td><strong><code>&lt;signal.h&gt;</code></strong></td><td>提供信号处理相关函数，如 <code>signal</code>、<code>raise</code>、<code>kill</code> 等。</td></tr><tr><td><strong><code>&lt;pthread.h&gt;</code></strong></td><td>POSIX 线程库的头文件，用于多线程编程，如 <code>pthread_create</code> 等。</td></tr><tr><td><strong><code>&lt;sys/socket.h&gt;</code></strong></td><td>提供套接字编程相关函数和结构体，如 <code>socket</code>、<code>bind</code>、<code>connect</code> 等。</td></tr><tr><td><strong><code>&lt;netinet/in.h&gt;</code></strong></td><td>定义网络地址相关的结构体和常量，如 <code>sockaddr_in</code>、<code>INADDR_ANY</code> 等。</td></tr><tr><td><strong><code>&lt;arpa/inet.h&gt;</code></strong></td><td>提供 IP 地址转换函数，如 <code>inet_pton</code>、<code>inet_ntoa</code> 等。</td></tr><tr><td><strong><code>&lt;sys/wait.h&gt;</code></strong></td><td>提供进程等待相关函数，如 <code>wait</code>、<code>waitpid</code> 等。</td></tr><tr><td><strong><code>&lt;sys/mman.h&gt;</code></strong></td><td>提供内存映射相关函数，如 <code>mmap</code>、<code>munmap</code> 等。</td></tr><tr><td><strong><code>&lt;sys/epoll.h&gt;</code></strong></td><td>提供 epoll 多路复用接口函数，如 <code>epoll_create</code>、<code>epoll_wait</code> 等。</td></tr><tr><td><strong><code>&lt;poll.h&gt;</code></strong></td><td>提供 <code>poll</code> 多路复用接口的相关函数和常量。</td></tr><tr><td><strong><code>&lt;termios.h&gt;</code></strong></td><td>提供终端 I/O 控制接口，如设置串口属性的 <code>tcsetattr</code> 等。</td></tr><tr><td><strong><code>&lt;sys/ioctl.h&gt;</code></strong></td><td>提供设备 I/O 控制接口，如 <code>ioctl</code> 调用。</td></tr><tr><td><strong><code>&lt;ctype.h&gt;</code></strong></td><td>定义字符操作函数，如 <code>isalpha</code>、<code>isdigit</code>、<code>toupper</code> 等。</td></tr><tr><td><strong><code>&lt;assert.h&gt;</code></strong></td><td>提供断言功能，用于调试时检查程序中的逻辑条件。</td></tr><tr><td><strong><code>&lt;limits.h&gt;</code></strong></td><td>定义各种数据类型的限制值，如 <code>INT_MAX</code>、<code>CHAR_BIT</code> 等。</td></tr><tr><td><strong><code>&lt;float.h&gt;</code></strong></td><td>定义浮点类型的限制值，如 <code>FLT_MAX</code>、<code>DBL_MIN</code> 等。</td></tr><tr><td><strong><code>&lt;locale.h&gt;</code></strong></td><td>提供本地化支持函数，如 <code>setlocale</code>、<code>localeconv</code> 等。</td></tr><tr><td><strong><code>&lt;grp.h&gt;</code></strong></td><td>提供组信息相关函数，如 <code>getgrgid</code>、<code>getgrnam</code> 等。</td></tr><tr><td><strong><code>&lt;pwd.h&gt;</code></strong></td><td>提供用户信息相关函数，如 <code>getpwnam</code>、<code>getpwuid</code> 等。</td></tr><tr><td><strong><code>&lt;sys/resource.h&gt;</code></strong></td><td>提供系统资源限制相关函数，如 <code>getrlimit</code>、<code>setrlimit</code> 等。</td></tr></tbody></table></div><h2 id="系统数据类型选录"><a href="#系统数据类型选录" class="headerlink" title="系统数据类型选录"></a>系统数据类型选录</h2><div class="table-container"><table><thead><tr><th>数据类型</th><th>SUSv3 类型需求</th><th>描述</th></tr></thead><tbody><tr><td><code>blkcnt_t</code></td><td>有符号整型</td><td>文件块数量（15.1 节）</td></tr><tr><td><code>blksize_t</code></td><td>有符号整型</td><td>文件块大小（15.1 节）</td></tr><tr><td><code>cc_t</code></td><td>无符号整型</td><td>终端特殊字符（62.4 节）</td></tr><tr><td><code>clock_t</code></td><td>整型或浮点型实数</td><td>以时钟周期计量的系统时间（10.7 节）</td></tr><tr><td><code>clockid_t</code></td><td>运算类型之一</td><td>针对 POSIX.1b 时钟和定时器函数的时钟标识符</td></tr><tr><td><code>comp_t</code></td><td>SUSv3 未作规范</td><td>经由压缩处理的时钟周期（28.1 节）</td></tr><tr><td><code>dev_t</code></td><td>运算类型之一</td><td>设备号，包含主、次设备号（15.1 节）</td></tr><tr><td><code>DIR</code></td><td>无类型要求</td><td>目录流（18.8 节）</td></tr><tr><td><code>fd_set</code></td><td>结构类型</td><td><code>select()</code>（63.2.1 节）中的文件描述符集合</td></tr><tr><td><code>fsblkcnt_t</code></td><td>无符号整型</td><td>文件系统块数量（14.11 节）</td></tr><tr><td><code>fsfilcnt_t</code></td><td>无符号整型</td><td>文件数量（14.11 节）</td></tr><tr><td><code>gid_t</code></td><td>整型</td><td>数值型组标识符（8.3 节）</td></tr><tr><td><code>id_t</code></td><td>整型</td><td>用以存放标识符的通用类型，其大小至少可放置 <code>pid_t</code>、<code>uid_t</code> 和 <code>gid_t</code> 类型</td></tr><tr><td><code>in_addr_t</code></td><td>32 位无符号整型</td><td>IPv4 地址（59.4 节）</td></tr><tr><td><code>in_port_t</code></td><td>16 位无符号整型</td><td>IP 端口号（59.4 节）</td></tr><tr><td><code>ino_t</code></td><td>无符号整型</td><td>文件 i-node 号（15.1 节）</td></tr><tr><td><code>key_t</code></td><td>运算类型之一</td><td>System V IPC 键（45.2 节）</td></tr><tr><td><code>mode_t</code></td><td>整型</td><td>文件权限及类型（15.1 节）</td></tr><tr><td><code>mqd_t</code></td><td>无类型要求</td><td>POSIX 消息队列描述符</td></tr><tr><td><code>msglen_t</code></td><td>无符号整型</td><td>System V 消息队列所允许的字节数（46.4 节）</td></tr><tr><td><code>msgqnum_t</code></td><td>无符号整型</td><td>System V 消息队列中的消息数量（46.4 节）</td></tr><tr><td><code>nfds_t</code></td><td>无符号整型</td><td><code>poll()</code>（63.2.2 节）中的文件描述符数量</td></tr><tr><td><code>nlink_t</code></td><td>整型</td><td>文件的（硬）连接数量（15.1 节）</td></tr><tr><td><code>off_t</code></td><td>有符号整型</td><td>文件偏移量或大小（4.7 节及 15.1 节）</td></tr><tr><td><code>pid_t</code></td><td>有符号整型</td><td>进程 ID、进程组 ID 或会话 ID（6.3 节、34.2 节、34.3 节）</td></tr><tr><td><code>ptrdiff_t</code></td><td>有符号整型</td><td>两指针差值，为有符号整型</td></tr><tr><td><code>rlim_t</code></td><td>无符号整型</td><td>资源限制（36.2 节）</td></tr><tr><td><code>sa_family_t</code></td><td>无符号整型</td><td>套接字地址族（56.4 节）</td></tr><tr><td><code>shmatt_t</code></td><td>无符号整型</td><td>与 System V 共享内存段相连的进程数量</td></tr><tr><td><code>sig_atomic_t</code></td><td>整型</td><td>可进行原子访问的数据类型（21.1.3 节）</td></tr><tr><td><code>siginfo_t</code></td><td>结构类型</td><td>信号起源的相关信息（21.4 节）</td></tr><tr><td><code>sigset_t</code></td><td>整型或结构类型</td><td>信号集合（20.9 节）</td></tr><tr><td><code>size_t</code></td><td>无符号整型</td><td>对象大小（以字节数计）</td></tr><tr><td><code>socklen_t</code></td><td>至少 32 位的整型</td><td>套接字地址结构大小（以字节数计）（56.3 节）</td></tr><tr><td><code>speed_t</code></td><td>无符号整型</td><td>终端线速度（62.7 节）</td></tr><tr><td><code>ssize_t</code></td><td>有符号整型</td><td>字节数或（为负时）标识错误</td></tr><tr><td><code>stack_t</code></td><td>结构类型</td><td>对备选信号栈的描述（21.3 节）</td></tr><tr><td><code>suseconds_t</code></td><td>有符号整型，范围为 [-1,1000000]</td><td>微秒级的时间间隔（10.1 节）</td></tr><tr><td><code>tcflag_t</code></td><td>无符号整型</td><td>终端模式标志位的位掩码（62.2 节）</td></tr><tr><td><code>time_t</code></td><td>整型或浮点型实数</td><td>自所谓纪元（Epoch）（10.1 节）始，以秒计的日历时间</td></tr><tr><td><code>timer_t</code></td><td>运算类型之一</td><td>POSIX.1b 间隔定时器函数（23.6 节）的定时器标识符</td></tr><tr><td><code>uid_t</code></td><td>整型</td><td>数值型用户标识符（8.1 节）</td></tr></tbody></table></div><h2 id="文件-I-O：通用的-I-O-模型"><a href="#文件-I-O：通用的-I-O-模型" class="headerlink" title="文件 I/O：通用的 I/O 模型"></a>文件 I/O：通用的 I/O 模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所有执行 <strong>I/O 操作的系统调用</strong>都以<strong>文件描述符</strong>，一个<strong>非负整数</strong>（通常是小整数），来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。针对每个进程，文件描述符都自成一套按照。惯例，大多数程序都期望能够使用 3 种标准的文件描述符，如下表</p><div class="table-container"><table><thead><tr><th>文件描述符</th><th>用 途</th><th><strong>POSIX</strong> 名称</th><th><strong>stdio</strong> 流</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td>STDIN_FILENO</td><td>stdin</td></tr><tr><td>1</td><td>标准输出</td><td>STDOUT_FILENO</td><td>stdout</td></tr><tr><td>2</td><td>标准错误</td><td>STDERR_FILENO</td><td>stder</td></tr></tbody></table></div><p><strong>I/O 操作的 4 个主要系统调用</strong></p><p>1.<code>int open(const char *pathname, int flags, mode_t mode);</code></p><p>2.<code>ssize_t read(int fd, void *buffer, size_t count);</code></p><p>3.<code>ssize_t write(int fd, const void *buffer, size_t count);</code></p><p>4.<code>int close(int fd);</code></p><h3 id="通用-I-O"><a href="#通用-I-O" class="headerlink" title="通用 I/O"></a>通用 I/O</h3><p>UNIX I/O 模型的显著特点之一是其输入/输出的<strong>通用性</strong>概念。这意味着使用 4 个同样的系统调用 open()、read()、write()和 close()可以对<strong>所有类型的文件</strong>执行 I/O 操作，包括终端之类的设备。因此，仅使用这些系统调用编写的程序，将对任何类型的文件有效。</p><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h3><p>open()调用既能打开一个业已存在的文件，也能<strong>创建</strong>并打开一个新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><strong>文件访问模式标志</strong></p><p><code>O_RDONLY</code>,<code>O_WRONLY</code>和<code>O_RDWR</code>这三种只能选择一种</p><div class="table-container"><table><thead><tr><th>标志</th><th>用途</th><th>统一 UNIX 规范版本</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>以只读方式打开</td><td>v3</td></tr><tr><td><code>O_WRONLY</code></td><td>以只写方式打开</td><td>v3</td></tr><tr><td><code>O_RDWR</code></td><td>以读写方式打开</td><td>v3</td></tr><tr><td><code>O_CLOEXEC</code></td><td>设置 close-on-exec 标志（自 Linux 2.6.23 版本开始）</td><td>v4</td></tr><tr><td><code>O_CREAT</code></td><td>若文件不存在则创建之</td><td>v3</td></tr><tr><td><code>O_DIRECT</code></td><td>无缓冲的输入/输出</td><td></td></tr><tr><td><code>O_DIRECTORY</code></td><td>如果 pathname 不是目录，则失败</td><td>v4</td></tr><tr><td><code>O_EXCL</code></td><td>结合 O_CREAT 参数使用，专门用于创建文件</td><td>v3</td></tr><tr><td><code>O_LARGEFILE</code></td><td>在 32 位系统中使用此标志打开大文件</td><td></td></tr><tr><td><code>O_NOATIME</code></td><td>调用 read() 时，不修改文件最近访问时间（自 Linux 2.6.8 版本开始）</td><td></td></tr><tr><td><code>O_NOCTTY</code></td><td>不要让 pathname（所指向的终端设备）成为控制终端</td><td>v3</td></tr><tr><td><code>O_NOFOLLOW</code></td><td>对符号链接不予解引用</td><td>v4</td></tr><tr><td><code>O_TRUNC</code></td><td>截断已有文件，使其长度为零</td><td>v3</td></tr><tr><td><code>O_APPEND</code></td><td>总在文件尾部追加数据</td><td>v3</td></tr><tr><td><code>O_ASYNC</code></td><td>当 I/O 操作可行时，产生信号（signal）通知进程</td><td></td></tr><tr><td><code>O_DSYNC</code></td><td>提供同步的 I/O 数据完整性（自 Linux 2.6.33 版本开始）</td><td>v3</td></tr><tr><td><code>O_NONBLOCK</code></td><td>以非阻塞方式打开</td><td>v3</td></tr><tr><td><code>O_SYNC</code></td><td>以同步方式写入文件</td><td>v3</td></tr></tbody></table></div><p><strong><code>open()</code> 函数的常见错误</strong></p><div class="table-container"><table><thead><tr><th>错误代码</th><th>描述</th></tr></thead><tbody><tr><td><code>EACCES</code></td><td>无权限以指定方式打开文件，可能因目录权限限制、文件不存在且无法创建。</td></tr><tr><td><code>EISDIR</code></td><td>尝试以写方式打开目录文件（不允许）。</td></tr><tr><td><code>EMFILE</code></td><td>进程已打开文件描述符数量达到限制。</td></tr><tr><td><code>ENFILE</code></td><td>系统文件打开数量达到上限。</td></tr><tr><td><code>ENOENT</code></td><td>文件不存在且未指定 <code>O_CREAT</code>，或路径中目录不存在。</td></tr><tr><td><code>EROFS</code></td><td>文件隶属只读文件系统，试图以写方式打开。</td></tr><tr><td><code>ETXTBSY</code></td><td>文件为正在运行的可执行文件，系统禁止修改。</td></tr></tbody></table></div><blockquote><p><strong>注意</strong>: 更多错误原因可查看 <code>man 2 open</code> 手册。</p></blockquote><h3 id="creat-函数"><a href="#creat-函数" class="headerlink" title="creat()函数"></a>creat()函数</h3><p>在早期的 UNIX 实现中，open()只有两个参数，无法创建新文件，而是使用 creat()系统调用来创建并打开一个新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>creat()系统调用根据 <code>pathname</code> 参数创建并打开一个文件，若文件已存在，则打开文件，并清空文件内容，将其长度清 0。creat()返回一文件描述符，供后续系统调用使用。<code>creat()</code>系统调用等价于如下 <code>open()</code>调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd =open(pathname,<span class="number">0</span>_WRONLY | O_CREAT | O_TRUNC,mode);</span><br></pre></td></tr></table></figure><h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h3><p>read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ssizet <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buffer,sizet count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回读取的字节数，EOF（文件结束）时返回 0，出错时返回 -1</span></span><br></pre></td></tr></table></figure><p><code>count</code> 参数指定最多能读取的字节数。（<code>size_t</code>数据类型属于无符号整数类型。）<code>buffer</code> 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 <code>count</code> 个字节。</p><h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write()函数"></a>write()函数</h3><p>write()系统调用将数据写入一个已打开的文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ssize t <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buffer,sizet count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回写入的字节数，出错时返回 -1</span></span><br></pre></td></tr></table></figure><p><code>write()</code>调用的参数含义与 <code>read()</code>调用相类似。<code>buffer</code> 参数为要写入文件中数据的内存地址，<code>count</code>参数为欲从<code>buffer</code> 写入文件的数据字节数，<code>fd</code> 参数为一文件描述符，指代数据要写入的文件。如果 <code>write()</code>调用成功，将返回实际写入文件的字节数，该返回值可能小于 <code>count</code> 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。</p><h3 id="close-函数"><a href="#close-函数" class="headerlink" title="close()函数"></a>close()函数</h3><p>close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当一进程终止时，将<strong>自动关闭</strong>其已打开的所有文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回 0，出错时返回 -1</span></span><br></pre></td></tr></table></figure><h3 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek()函数"></a>lseek()函数</h3><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 <code>read()</code>或 <code>write()</code>操作的文件起始位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。文件打开时，会将文件偏移量设置为指向文件开始，以后每次<code>read()</code>或 <code>write()</code>调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 <code>read()</code>和 <code>write()</code>调用将按顺序递进，对文件进行操作。针对文件描述符 <code>fd</code> 参数所指代的已打开文件，<code>lseek()</code>系统调用依照 <code>offset</code> 和 <code>whence</code> 参数值调整该文件的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">off t <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd,off t offset,<span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回新的文件偏移量，出错时返回 -1</span></span><br></pre></td></tr></table></figure><p><code>offset</code> 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型数。）<code>whence</code> 参数则表明应参照哪个基点来解释 <code>offset</code> 参数，应为下列其中之一：</p><div class="table-container"><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>将文件偏移量设置为从文件头部起始点开始的 offset 个字节。</td></tr><tr><td>SEEK_CUR</td><td>相对于当前文件偏移量，将文件偏移量调整 offset 个字节。</td></tr><tr><td>SEEK_END</td><td>将文件偏移量设置为起始于文件尾部的 offset 个字节。offset 参数从文件最后一个字节之后算起。</td></tr></tbody></table></div><h2 id="深入探究文件-I-O"><a href="#深入探究文件-I-O" class="headerlink" title="深入探究文件 I/O"></a>深入探究文件 I/O</h2><h3 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl()函数"></a>fcntl()函数</h3><p><code>fcntl()</code>系统调用对一个打开的文件描述符执行一系列控制操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl,h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> cmd,...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功时返回取决于cmd，错误时返回-1</span></span><br></pre></td></tr></table></figure><p>cmd 参数所支持的操作范围很广,常用来获取/设置文件描述符标志,获取/设置文件状态标志,设置/获取文件锁,复制文件描述符。fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</p><details class="folding-tag" green><summary>使用示例(获取和设置文件描述符标志：`F_GETFD` 和 `F_SETFD`)</summary><div class="content"><p>获取或设置文件描述符的标志，例如 <code>FD_CLOEXEC</code>（关闭文件时不被子进程继承）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件描述符标志</span></span><br><span class="line">    <span class="type">int</span> flags = fcntl(fd, F_GETFD);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_GETFD&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial FD flags: %d\n&quot;</span>, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 FD_CLOEXEC 标志</span></span><br><span class="line">    flags |= FD_CLOEXEC;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFD, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_SETFD&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FD_CLOEXEC flag set.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(获取和设置文件状态标志：`F_GETFL` 和 `F_SETFL`)</summary><div class="content"><p>获取或修改文件的状态标志，例如非阻塞模式（<code>O_NONBLOCK</code>）或追加模式（<code>O_APPEND</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_APPEND, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件状态标志</span></span><br><span class="line">    <span class="type">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_GETFL&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial file status flags: %d\n&quot;</span>, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加非阻塞标志</span></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_SETFL&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;O_NONBLOCK flag set.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(文件锁：`F_SETLK` 和`F_SETLKW`和 `F_GETLK`)</summary><div class="content"><p>设置、获取或阻塞文件锁（适合实现进程间文件同步）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_type = F_WRLCK;  <span class="comment">// 写锁</span></span><br><span class="line">    lock.l_whence = SEEK_SET;</span><br><span class="line">    lock.l_start = <span class="number">0</span>;       <span class="comment">// 从文件开头</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;         <span class="comment">// 锁住整个文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试设置锁</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_SETLK&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File locked.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟文件操作</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.l_type = F_UNLCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_SETLK&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File unlocked.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(复制文件描述符：`F_DUPFD` 和 `F_DUPFD_CLOEXEC`)</summary><div class="content"><p>类似于 <code>dup()</code> 和 <code>dup3()</code>，但支持更精细的控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制文件描述符，最小值为 5</span></span><br><span class="line">    <span class="type">int</span> new_fd = fcntl(fd, F_DUPFD, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl F_DUPFD&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;New file descriptor: %d\n&quot;</span>, new_fd);</span><br><span class="line"></span><br><span class="line">    write(new_fd, <span class="string">&quot;Hello, fcntl!\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(new_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details><h3 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup()函数"></a>dup()函数</h3><p>dup()调用复制一个打开的文件描述符 oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回（新）文件描述符，错误时返回-1</span></span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> new_fd = dup(fd);</span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(new_fd, <span class="string">&quot;Hello, dup!\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    close(new_fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行完毕后文件 <code>example.txt</code> 会包含 <code>Hello, dup!</code></p></div></details><h3 id="dup2-函数"><a href="#dup2-函数" class="headerlink" title="dup2()函数"></a>dup2()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd,<span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回（新）文件描述符，错误时返回-1</span></span><br></pre></td></tr></table></figure><p><code>dup2()</code>系统调用会为 <code>oldfd</code> 参数所指定的文件描述符创建副本，其编号由 <code>newfd</code> 参数指定。如果由 <code>newfd</code> 参数所指定编号的文件描述符之前已经打开，那么 <code>dup2()</code>会首先将其关闭。（<code>dup2()</code>调用会默然忽略 <code>newfd</code> 关闭期间出现的任何错误。故此，编码时更为安全的做法是：在调用<code>dup2()</code>之前，若 <code>newfd</code> 已经打开，则应显式调用 <code>close()</code>将其关闭。）如果 <code>oldfd</code> 和 <code>newfd</code> 相同，<code>dup2()</code> 直接返回 <code>newfd</code>，不会关闭或复制。</p><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, STDOUT_FILENO);  <span class="comment">// 重定向标准输出到文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这将被写入文件而不是终端.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行完毕后文件<code>example.txt</code> 会包含重定向后的输出内容<code>&quot;这将被写入文件而不是终端.&quot;</code>。</p></div></details><h3 id="dup3-函数"><a href="#dup3-函数" class="headerlink" title="dup3()函数"></a>dup3()函数</h3><p>dup3()系统调用完成的工作与 dup2()相同，只是新增了一个附加参数 flag，这是一个可以修改系统调用行为的位掩码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GNU SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup3</span><span class="params">(<span class="type">int</span> oldfd,<span class="type">int</span> newfd,<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功时返回（新）文件描述符，错误时返回-1</span></span><br></pre></td></tr></table></figure><p>目前，dup3()只支持一个标志 O_CLOEXEC，这将促使内核为新文件描述符设置 close-on-exec标志（FD_CLOEXEC）。</p><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup3(fd, <span class="number">5</span>, O_CLOEXEC);  <span class="comment">// 复制到文件描述符 5，并设置 O_CLOEXEC</span></span><br><span class="line">    write(<span class="number">5</span>, <span class="string">&quot;Hello, dup3!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行完毕后文件<code>example.txt</code> 会包含 <code>Hello, dup3!</code></p></div></details><h3 id="pread-函数"><a href="#pread-函数" class="headerlink" title="pread()函数"></a>pread()函数</h3><p>系统调用 <code>pread()</code>完成与 <code>read()</code>相类似的工作，只是前者会在 <code>offset</code> 参数所指定的位置进行文件 <code>I/O</code> 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> count,<span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回读取的字节数，EOF（文件结束）时返回 0，发生错误时返回 -1。</span></span><br></pre></td></tr></table></figure><p><code>pread()</code>系统调用相当于把下面的操作,纳入了原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> = orig;</span><br><span class="line"><span class="type">ssize_t</span> t;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>]; <span class="comment">// 定义一个大小为 1024 字节的缓冲区</span></span><br><span class="line"><span class="comment">// 获取当前文件描述符 fd 的文件偏移量，并将其保存到 orig 中,SEEK_CUR 表示相对于当前偏移量的位置。</span></span><br><span class="line">orig = lseek(fd,<span class="number">0</span>,SEEK_CUR);</span><br><span class="line"><span class="comment">// 将文件偏移量移动到指定的 offset 位置。SEEK_SET 表示从文件的开头计算偏移量。</span></span><br><span class="line">lseek(fd,offset,SEEK_SET);</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(fd, buf, len)</span>;</span><br><span class="line"><span class="comment">// 从文件描述符 fd 处读取最多 len 字节的数据到缓冲区 buf 中，返回实际读取的字节数。</span></span><br><span class="line">s = read(fd,buf,len);</span><br><span class="line"><span class="comment">// 将文件偏移量恢复到之前保存的 orig 值。这样，文件的读取或写入位置不会因为这段操作而改变。</span></span><br><span class="line"><span class="number">1</span>seek(fd,orig,SEEK_SET);</span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从偏移量 10 开始读取 15 个字节</span></span><br><span class="line">    bytesRead = pread(fd, buf, <span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pread failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符串结束符</span></span><br><span class="line">    buf[bytesRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data read: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>example.txt</code>的文件内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></table></figure><p>运行上述程序会输出：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data <span class="built_in">read</span>: ABCDEFGHIJKLM</span><br></pre></td></tr></table></figure></div></details><h3 id="pwrite-函数"><a href="#pwrite-函数" class="headerlink" title="pwrite()函数"></a>pwrite()函数</h3><p>系统调用 <code>pwrite()</code>完成与 <code>write()</code>相类似的工作，只是前者会在 <code>offset</code> 参数所指定的位置进行文件 <code>I/O</code> 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回写入的字节数，EOF（文件结束）时返回 0，发生错误时返回 -1。</span></span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, pwrite!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytesWritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件（如果文件不存在则创建）</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从偏移量 5 开始写入数据</span></span><br><span class="line">    bytesWritten = pwrite(fd, data, <span class="built_in">strlen</span>(data), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytesWritten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pwrite failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bytes written: %zd\n&quot;</span>, bytesWritten);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>example.txt</code>的文件内容</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890</span></span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code> 内容变为：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span>Hello, pwrite!</span><br></pre></td></tr></table></figure></div></details><h3 id="readv-函数"><a href="#readv-函数" class="headerlink" title="readv()函数"></a>readv()函数</h3><p><code>readv()</code> 是一种 POSIX 系统调用，用于从文件描述符中读取数据到多个缓冲区。它的主要功能是将数据按顺序填充到指定的多个缓冲区中，而不是将数据集中到一个缓冲区中。这样可以减少内存拷贝，提高性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回读取的总字节数，即所有缓冲区中实际填充的字节数的总和。返回 -1，并设置全局变量 errno 表示错误原因。</span></span><br></pre></td></tr></table></figure><p>这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据。数组 <code>iov</code> 定义了一组用来传输数据的缓冲区。整型数 <code>iovcnt</code> 则指定了 <code>iov</code> 的成员个数。<code>iov</code> 中的每个成员都是如下形式的数据结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  <span class="comment">// 指向缓冲区的起始地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;   <span class="comment">// 缓冲区的长度（以字节为单位）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个 iovec 缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;          <span class="comment">// 第一个缓冲区</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buf1);  <span class="comment">// 第一个缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;          <span class="comment">// 第二个缓冲区</span></span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(buf2);  <span class="comment">// 第二个缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取数据到 iov 中的缓冲区</span></span><br><span class="line">    bytesRead = readv(fd, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;readv failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印读取到的内容</span></span><br><span class="line">    buf1[iov[<span class="number">0</span>].iov_len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保缓冲区末尾有 &#x27;\0&#x27;</span></span><br><span class="line">    buf2[bytesRead - <span class="keyword">sizeof</span>(buf1) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffer 1: %s\n&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffer 2: %s\n&quot;</span>, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>example.txt</code>的文件内容</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HelloWorldThisIsReadvExample</span></span><br></pre></td></tr></table></figure><p>运行程序后，输出为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Buffer</span> <span class="number">1</span>: HelloWorl</span><br><span class="line"><span class="attribute">Buffer</span> <span class="number">2</span>: dThisIsReadvEx</span><br></pre></td></tr></table></figure></div></details><h3 id="writev-函数"><a href="#writev-函数" class="headerlink" title="writev()函数"></a>writev()函数</h3><p><code>writev()</code> 是一个系统调用，允许程序将多个非连续缓冲区的数据写入到文件描述符中。它可以一次性地将分散的多个缓冲区内容输出到目标文件（或套接字）中，而不需要手动合并数据，从而提高性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功：返回实际写入的字节数。失败：返回 -1 并设置 errno 以指示错误。</span></span><br></pre></td></tr></table></figure><p><code>writev()</code>系统调用实现了集中输出：将 <code>iov</code> 所指定的所有缓冲区中的数据拼接（“集中”）起来，然后以连续的字节序列写入文件描述符 <code>fd</code> 指代的文件中。对缓冲区中数据的“集中”始于<code>iov[0]</code>所指定的缓冲区，并按数组顺序展开。像 <code>readv()</code>调用一样，<code>writev()</code>调用也属于原子操作，即所有数据将一次性地从用户内存传输到 <code>fd</code> 指代的文件中。因此，在向普通文件写入数据时，<code>writev()</code>调用会把所有的请求数据连续写入文件，而不会在其他进程（或线程）写操作的影响下1 分散地写入文件2 。如同 <code>write()</code>调用，<code>writev()</code>调用也可能存在部分写的问题。因此，必须检查 <code>writev()</code>调用的返回值，以确定写入的字节数是否与要求相符。</p><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">ssize_t</span> bytesWritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以写入</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *buf1 = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *buf2 = <span class="string">&quot;World!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 iovec 数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="comment">// void * 是 C 和 C++ 语言中一种通用的指针类型，表示 &quot;指向未知类型的指针&quot;。</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = (<span class="type">void</span> *)buf1;  <span class="comment">// 第一个缓冲区</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(buf1);  <span class="comment">// 第一个缓冲区的长度</span></span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = (<span class="type">void</span> *)buf2;  <span class="comment">// 第二个缓冲区</span></span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(buf2);  <span class="comment">// 第二个缓冲区的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 writev 写入文件</span></span><br><span class="line">    bytesWritten = writev(fd, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytesWritten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;writev failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully written %zd bytes.\n&quot;</span>, bytesWritten);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code>文件内容为：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure></div></details><h3 id="preadv-函数"><a href="#preadv-函数" class="headerlink" title="preadv()函数"></a>preadv()函数</h3><p><code>preadv()</code> 是 Linux 和 Unix 系统中的系统调用，用于 <strong>从文件描述符的指定偏移量读取数据，并存储到多个缓冲区中</strong>。与 <code>readv()</code> 不同，<code>preadv()</code> 的一个显著特性是它是一个 <strong>“原子” 操作</strong>，它结合了 <code>readv()</code> 和 <code>lseek()</code> 的功能，同时不会更改文件描述符的文件偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功：返回实际读取的字节数。失败：返回 -1，并设置 errno 指定错误原因。</span></span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">10</span>], buf2[<span class="number">20</span>];</span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 iovec 缓冲区</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(buf1);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(buf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 preadv 从偏移量读取数据</span></span><br><span class="line">    bytesRead = preadv(fd, iov, <span class="number">2</span>, offset);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;preadv failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bytes read: %zd\n&quot;</span>, bytesRead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffer 1: %.*s\n&quot;</span>, (<span class="type">int</span>)iov[<span class="number">0</span>].iov_len, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buffer 2: %.*s\n&quot;</span>, (<span class="type">int</span>)(bytesRead - iov[<span class="number">0</span>].iov_len), buf2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件 <code>example.txt</code> 的内容是：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HelloWorldThisIspreadvExample</span></span><br></pre></td></tr></table></figure><p>运行程序后，输出结果为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Buffer</span> <span class="number">1</span>: WorldThis</span><br><span class="line"><span class="attribute">Buffer</span> <span class="number">2</span>: IspreadvExampl</span><br></pre></td></tr></table></figure></div></details><h3 id="pwritev-函数"><a href="#pwritev-函数" class="headerlink" title="pwritev()函数"></a>pwritev()函数</h3><p><code>pwritev()</code> 是 Linux 和 Unix 系统中的系统调用，用于 <strong>从多个缓冲区将数据写入文件的指定偏移量</strong>。与 <code>writev()</code> 的区别在于，<code>pwritev()</code> 提供了一个显式的偏移量参数，写操作从文件中的指定位置开始，而不会更改文件描述符的当前偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功：返回实际写入的字节数。失败：返回 -1，并设置 errno 指定错误原因。</span></span><br></pre></td></tr></table></figure><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">ssize_t</span> bytesWritten;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="type">char</span> buf1[] = <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 iovec 缓冲区</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(buf1);</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(buf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 pwritev 从偏移量 0 开始写入数据</span></span><br><span class="line">    bytesWritten = pwritev(fd, iov, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pwritev failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bytes written: %zd\n&quot;</span>, bytesWritten);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code>文件内容为</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Bytes</span> written: <span class="number">12</span></span><br></pre></td></tr></table></figure></div></details><h3 id="truncate-函数"><a href="#truncate-函数" class="headerlink" title="truncate() 函数"></a>truncate() 函数</h3><p><code>truncate()</code> 是一个文件操作系统调用，用于将指定文件的大小调整为指定值。如果文件变小，超出部分将被截断；如果文件变大，扩展部分通常填充为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功：返回 0。失败：返回 -1，并设置 errno 指定错误原因。</span></span><br></pre></td></tr></table></figure><p><strong><code>path</code></strong>:表示文件路径，指向需要调整大小的文件。</p><p><strong><code>length</code></strong>:新的文件大小（以字节为单位）。若文件当前大小大于 <code>length</code>，多余部分会被删除。若文件当前大小小于 <code>length</code>，文件会被扩展，新增部分通常填充为零（文件系统依赖）。</p><details class="folding-tag" green><summary>使用示例(截断文件)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filePath = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">off_t</span> newSize = <span class="number">5</span>;  <span class="comment">// 截断到 5 字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开或创建文件并写入内容</span></span><br><span class="line">    <span class="type">int</span> fd = open(filePath, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello, World!&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截断文件</span></span><br><span class="line">    <span class="keyword">if</span> (truncate(filePath, newSize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncate failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File &#x27;%s&#x27; has been truncated to %ld bytes.\n&quot;</span>, filePath, (<span class="type">long</span>)newSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code>文件内容为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello</span></span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(扩展文件大小)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filePath = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">off_t</span> newSize = <span class="number">20</span>;  <span class="comment">// 扩展到 20 字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并写入初始内容</span></span><br><span class="line">    <span class="type">int</span> fd = open(filePath, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (truncate(filePath, newSize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncate failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File &#x27;%s&#x27; has been extended to %ld bytes.\n&quot;</span>, filePath, (<span class="type">long</span>)newSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code>文件内容为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span></span><br></pre></td></tr></table></figure></div></details><h3 id="ftruncate-函数"><a href="#ftruncate-函数" class="headerlink" title="ftruncate()函数"></a>ftruncate()函数</h3><p><code>ftruncate()</code> 是一个文件操作系统调用，用于通过文件描述符调整打开文件的大小。如果文件变小，超出部分会被截断；如果文件变大，扩展部分通常填充为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功：返回 0。失败：返回 -1，并设置 errno 以指示错误原因。</span></span><br></pre></td></tr></table></figure><p><strong><code>fd</code></strong>:打开文件的文件描述符。文件描述符必须是可写的。</p><p><strong><code>length</code></strong>:调整后的文件大小（以字节为单位）。若文件当前大小大于 <code>length</code>，多余部分会被删除。若文件当前大小小于 <code>length</code>，文件会被扩展，新增部分通常填充为零（文件系统依赖）。</p><details class="folding-tag" green><summary>使用示例(截断文件)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filePath = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">off_t</span> newSize = <span class="number">5</span>;  <span class="comment">// 将文件大小调整为 5 字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filePath, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入初始内容</span></span><br><span class="line">    write(fd, <span class="string">&quot;Hello, World!&quot;</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, newSize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftruncate failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File &#x27;%s&#x27; truncated to %ld bytes.\n&quot;</span>, filePath, (<span class="type">long</span>)newSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code>文件内容为</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello</span></span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(扩展文件大小)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filePath = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">off_t</span> newSize = <span class="number">20</span>;  <span class="comment">// 将文件大小扩展为 20 字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filePath, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入初始内容</span></span><br><span class="line">    write(fd, <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, newSize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftruncate failed&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File &#x27;%s&#x27; extended to %ld bytes.\n&quot;</span>, filePath, (<span class="type">long</span>)newSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，<code>example.txt</code>文件内容为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span></span><br></pre></td></tr></table></figure></div></details><h3 id="mkstemp-函数"><a href="#mkstemp-函数" class="headerlink" title="mkstemp()函数"></a>mkstemp()函数</h3><p><code>mkstemp()</code> 是一个用于创建临时文件的系统调用。它会创建一个唯一命名的临时文件，防止文件名冲突，并返回一个文件描述符，用于后续文件操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功：返回一个打开的文件描述符（以读写模式打开）。失败：返回 -1，并设置 errno 以指示错误原因。</span></span><br></pre></td></tr></table></figure><p><strong><code>template</code></strong>:是一个指向以 NULL 结尾的字符串的指针。此字符串必须以 <strong>六个连续的 X</strong> 结尾（如 <code>&quot;tempXXXXXX&quot;</code>）。<code>mkstemp()</code> 会用唯一的文件名替换这些 X，生成文件。注意：该字符串会被修改，最终包含生成的文件名。</p><details class="folding-tag" green><summary>使用示例(创建临时文件)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> template[] = <span class="string">&quot;/tmp/mytempXXXXXX&quot;</span>;  <span class="comment">// 模板必须以 6 个 X 结尾</span></span><br><span class="line">    <span class="type">int</span> fd = mkstemp(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkstemp failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Temporary file created: %s\n&quot;</span>, template);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    write(fd, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭并删除文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 调用 unlink() 删除临时文件。</span></span><br><span class="line">    unlink(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(在指定目录中创建临时文件)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> template[] = <span class="string">&quot;./tempXXXXXX&quot;</span>;  <span class="comment">// 在当前目录创建临时文件</span></span><br><span class="line">    <span class="type">int</span> fd = mkstemp(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkstemp failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Temporary file created: %s\n&quot;</span>, template);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不删除文件，仅关闭描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><p><strong>注意事项</strong></p><p><strong>安全性</strong></p><ul><li>避免使用不安全的函数（如 <code>tmpnam()</code>），<code>mkstemp()</code> 能更好地防止文件名冲突和竞态条件。</li></ul><p><strong>目录权限</strong></p><ul><li>如果指定路径中的目录不可写，<code>mkstemp()</code> 会失败。</li></ul><p><strong>文件名限制</strong></p><ul><li>模板中的 X 必须不少于 6 个，否则 <code>mkstemp()</code> 会报错。</li></ul><p><strong>文件清理</strong></p><ul><li>创建的临时文件不会自动删除，开发者需要在不使用时调用 <code>unlink()</code> 手动删除文件。</li></ul><h3 id="tmpfile-函数"><a href="#tmpfile-函数" class="headerlink" title="tmpfile()函数"></a>tmpfile()函数</h3><p><code>tmpfile()</code> 是一个标准 C 库函数，用于创建临时文件。它会创建一个匿名的临时文件，该文件在关闭时或程序退出时会自动删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功：返回指向临时文件的文件指针 (FILE *)。失败：返回 NULL，并设置 errno 表示错误原因。</span></span><br></pre></td></tr></table></figure><p>tmpfile()函数执行成功，将返回一个文件流供 stdio 库函数使用。文件流关闭后将自动删除临时文件。为达到这一目的，tmpfile()函数会在打开文件后，从内部立即调用 unlink()来删除该文件名 。</p><details class="folding-tag" green><summary>使用示例(创建并写入临时文件)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = tmpfile();</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;tmpfile failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到临时文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;This is a temporary file.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;It will be automatically deleted.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针重置到文件开头</span></span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并打印数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭临时文件（自动删除）</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(临时文件用于交换数据)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *tempFile = tmpfile();</span><br><span class="line">    <span class="keyword">if</span> (tempFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;tmpfile failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> count = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到临时文件</span></span><br><span class="line">    fwrite(data, <span class="keyword">sizeof</span>(<span class="type">int</span>), count, tempFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针重置到文件开头</span></span><br><span class="line">    rewind(tempFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据并打印</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">while</span> (fread(&amp;value, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">1</span>, tempFile) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭临时文件</span></span><br><span class="line">    fclose(tempFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="getpid-函数"><a href="#getpid-函数" class="headerlink" title="getpid()函数"></a>getpid()函数</h3><p><code>getpid()</code> 是一个标准的系统调用，用于获取当前进程的进程标识符（PID）。</p><p>每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。对各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。比如，系统调用<code>kill()</code>允许调用者向拥有特定进程号的进程发送一个信号。当需要创建一个对某进程而言唯一的标识符时，进程号就会派上用场。常见的例子是将进程号作为与进程相关文件名的一部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程的 ID (pid_t 类型)。通常，进程 ID 是一个大于零的整数。</span></span><br></pre></td></tr></table></figure><p>getpid()返回值的数据类型为 pid_t，该类型是由 SUSv3 所规定的整数类型，专用于存储进程号。除了少数系统进程外，比如 init 进程（进程号为 1），程序与运行该程序进程的进程号之间没有固定关系。Linux 内核限制进程号需小于等于 32767。新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用。每当进程号达到 32767 的限制时，内核将重置进程号计数器，以便从小整数开始分配。</p><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current Process ID: %d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h3 id="getppid-函数"><a href="#getppid-函数" class="headerlink" title="getppid()函数"></a>getppid()函数</h3><p><code>getppid()</code> 是一个系统调用，用于获取当前进程的父进程标识符（Parent Process ID, PPID）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程的父进程的 ID (pid_t 类型)。通常是一个非负整数。特殊情况：当父进程被杀死后，当前进程的父进程会变为系统的 init 进程或其现代替代进程（如 systemd），这时返回的 PPID 为 1。</span></span><br></pre></td></tr></table></figure><p>实际上，每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父进程又有自己的父进程，以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。使用pstree(1)命令可以查看到这一“家族树”（family tree）。如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程，子进程后续对 getppid()的调用将返回进程号 1。通过查看由 Linux 系统所特有的/proc/PID/status 文件所提供的 PPid 字段，可以获知每个进程的父进程。</p><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ppid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent Process ID: %d\n&quot;</span>, ppid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h3 id="getenv-函数"><a href="#getenv-函数" class="headerlink" title="getenv()函数"></a>getenv()函数</h3><p><code>getenv()</code>函数能够从进程环境中检索单个值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功： 返回一个指向环境变量值的指针。如果环境变量存在，则返回其值的字符串指针。返回的值是指向环境变量中存储数据的内存，不要修改此内存的内容。失败： 返回 NULL，表示未找到指定的环境变量。</span></span><br></pre></td></tr></table></figure><p><strong><code>name</code></strong>: 环境变量的名称，必须是一个以空字符 <code>&#39;\0&#39;</code> 结尾的字符串。</p><p>功能说明:<strong><code>getenv()</code></strong> 检索环境变量的值。<strong>环境变量</strong> 是键值对形式的字符串，通常用于存储配置信息，如用户路径、系统设置等。如果环境变量存在，则返回指向该变量值的指针；如果不存在，则返回 <code>NULL</code>。</p><details class="folding-tag" green><summary>使用示例</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 PATH 环境变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Environment variable PATH not found.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PATH: %s\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取不存在的环境变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *notExist = getenv(<span class="string">&quot;NOT_EXIST&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (notExist == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Environment variable NOT_EXIST not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PATH</span>: <span class="regexp">/usr/bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/local/bin</span></span><br><span class="line"><span class="title class_">Environment</span> variable <span class="variable constant_">NOT_EXIST</span> <span class="keyword">not</span> found.</span><br></pre></td></tr></table></figure></div></details><p><strong>注意事项</strong></p><ol><li><p><strong>检查返回值</strong>： 环境变量可能不存在，使用前需检查返回值是否为 <code>NULL</code>。</p></li><li><p><strong>多线程使用</strong>： 在多线程程序中避免直接调用 <code>getenv()</code>，需要同步或使用线程安全的替代方法。</p></li><li><p><strong>与环境变量的关系</strong>： 环境变量由系统和用户定义，通常可以通过 <code>export</code> 命令设置。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MYVAR=<span class="string">&quot;HelloWorld&quot;</span></span><br></pre></td></tr></table></figure><p>然后可以在 C 程序中使用 <code>getenv(&quot;MYVAR&quot;)</code> 获取其值。</p></li></ol><h3 id="putenv-函数"><a href="#putenv-函数" class="headerlink" title="putenv()函数"></a>putenv()函数</h3><p><code>putenv()</code> 是一个标准 C 库函数，用于向环境中添加新的环境变量或修改已有的环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值0: 成功。-1: 失败（例如，内存不足时）。</span></span><br></pre></td></tr></table></figure><p><strong><code>string</code></strong>:一个以 <code>name=value</code> 格式表示的字符串，用于设置环境变量。<code>name</code> 是环境变量的名称，<code>value</code> 是对应的值。必须确保传递的字符串格式正确，且以 <code>\0</code> 结尾。</p><details class="folding-tag" green><summary>使用示例(添加新变量)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 添加环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (putenv(<span class="string">&quot;MYVAR=HelloWorld&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;putenv failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证变量是否已添加</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *value = getenv(<span class="string">&quot;MYVAR&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Environment variable MYVAR not found.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MYVAR: %s\n&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(修改已有变量)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="type">char</span> env[] = <span class="string">&quot;MYVAR=InitialValue&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (putenv(env) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;putenv failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before modification: %s\n&quot;</span>, getenv(<span class="string">&quot;MYVAR&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改变量的值</span></span><br><span class="line">    <span class="built_in">strcpy</span>(env, <span class="string">&quot;MYVAR=ModifiedValue&quot;</span>); <span class="comment">// 修改内存内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After modification: %s\n&quot;</span>, getenv(<span class="string">&quot;MYVAR&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><p><strong>注意事项</strong></p><ol><li><strong><code>string</code> 的内存管理</strong>：<ul><li><code>putenv()</code> 不复制传递的字符串，直接使用它的指针。</li><li>如果 <code>string</code> 是动态分配的，释放该内存可能导致环境变量变为非法。</li></ul></li><li><strong>修改内容的副作用</strong>：<ul><li>修改传递给 <code>putenv()</code> 的字符串内容会直接影响环境变量。</li><li>示例中，通过 <code>strcpy</code> 修改 <code>env</code> 后，<code>getenv()</code> 的返回值也会随之改变。</li></ul></li><li><strong>格式要求</strong>：<ul><li>必须以 <code>name=value</code> 格式传递字符串。</li><li>如果格式不正确，可能会导致不可预期的行为。</li></ul></li><li><strong>线程安全性</strong>：<ul><li><code>putenv()</code> 是 <strong>非线程安全</strong> 的。</li><li>在多线程程序中调用时，需确保同步机制，避免竞争条件。</li></ul></li><li><strong>性能问题</strong>：<ul><li>每次调用 <code>putenv()</code> 都可能导致环境变量表重新分配内存，影响性能。</li></ul></li><li><strong>建议使用 <code>setenv()</code> 替代</strong>：<ul><li><code>setenv()</code> 是线程安全的，并且会复制传入的值，避免了许多 <code>putenv()</code> 的问题。</li></ul></li></ol><h3 id="setenv-函数"><a href="#setenv-函数" class="headerlink" title="setenv()函数"></a>setenv()函数</h3><p><code>setenv()</code> 是一个标准 C 库函数，用于添加新的环境变量或修改现有的环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0: 成功。-1: 失败（例如，内存不足或参数无效）。错误时，errno 会被设置为具体错误码。</span></span><br></pre></td></tr></table></figure><p><strong><code>name</code></strong>:环境变量的名称。必须是有效的字符串，不能包含等号 (<code>=</code>)，且不能为空。</p><p><strong><code>value</code></strong>:环境变量的值。如果为空字符串，表示设置该变量为空值。</p><p><strong><code>overwrite</code></strong>:一个整型标志，用于指示是否允许覆盖已有的环境变量：<strong>非零值</strong>：如果环境变量已存在，将覆盖其值。<strong>零值</strong>：如果环境变量已存在，则不改变其值。</p><details class="folding-tag" green><summary>使用示例(添加新环境变量)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 添加新的环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">&quot;MYVAR&quot;</span>, <span class="string">&quot;HelloWorld&quot;</span>, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setenv failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否添加成功</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *value = getenv(<span class="string">&quot;MYVAR&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MYVAR: %s\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Environment variable MYVAR not found.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(覆盖已有变量)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    setenv(<span class="string">&quot;MYVAR&quot;</span>, <span class="string">&quot;InitialValue&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MYVAR before overwrite: %s\n&quot;</span>, getenv(<span class="string">&quot;MYVAR&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改已有变量</span></span><br><span class="line">    setenv(<span class="string">&quot;MYVAR&quot;</span>, <span class="string">&quot;ModifiedValue&quot;</span>, <span class="number">1</span>);  <span class="comment">// 允许覆盖</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MYVAR after overwrite: %s\n&quot;</span>, getenv(<span class="string">&quot;MYVAR&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="folding-tag" green><summary>使用示例(不覆盖已有变量)</summary><div class="content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    setenv(<span class="string">&quot;MYVAR&quot;</span>, <span class="string">&quot;InitialValue&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MYVAR before overwrite: %s\n&quot;</span>, getenv(<span class="string">&quot;MYVAR&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试不覆盖已有变量</span></span><br><span class="line">    setenv(<span class="string">&quot;MYVAR&quot;</span>, <span class="string">&quot;IgnoredValue&quot;</span>, <span class="number">0</span>);  <span class="comment">// 禁止覆盖</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MYVAR after no-overwrite attempt: %s\n&quot;</span>, getenv(<span class="string">&quot;MYVAR&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><p><strong>注意事项</strong></p><ol><li><strong>参数验证</strong>：<ul><li><code>name</code> 不能为空，且不能包含等号 (<code>=</code>)。</li><li>若传递非法参数，<code>setenv()</code> 将返回错误并设置 <code>errno</code>。</li></ul></li><li><strong>线程安全</strong>：<ul><li>多线程环境下，<code>setenv()</code> 是安全的。</li><li>但需要注意并发操作中对同一环境变量的竞争条件。</li></ul></li><li><strong>内存分配</strong>：<ul><li><code>setenv()</code> 会分配内存来存储环境变量，用户无需关心内存管理。</li><li>但频繁设置环境变量可能导致内存碎片化。</li></ul></li><li><strong>性能开销</strong>：<ul><li><code>setenv()</code> 每次调用可能需要重新调整环境表，频繁调用可能影响性能。</li></ul></li><li><strong>与 <code>putenv()</code> 的区别</strong>：<ul><li><code>setenv()</code> 复制输入字符串，<code>putenv()</code> 不会复制，直接使用指针。</li><li><code>setenv()</code> 更安全，但开销可能略高于 <code>putenv()</code>。</li></ul></li><li><strong>与 <code>unsetenv()</code> 配合使用</strong>：<ul><li>可以使用 <code>unsetenv()</code> 删除环境变量，确保环境表保持干净。</li></ul></li></ol><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h3><p>在诸多应用中，创建多个进程是任务分解时行之有效的方法。例如，某一网络服务器进程可在侦听客户端请求的同时，为处理每一请求而创建一新的子进程，与此同时，服务器进程会继续侦听更多的客户端连接请求。以此类手法分解任务，通常会简化应用程序的设计，同时提高了系统的并发性。（即，可同时处理更多的任务或请求。）系统调用 fork()创建一新进程（child），几近于对调用进程（parent）的翻版。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pid t <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在父进程中：成功时返回子进程的进程 ID，出错时返回 -1；</span></span><br><span class="line"><span class="comment">//在成功创建的子进程中：始终返回 0。</span></span><br></pre></td></tr></table></figure><p>理解 fork()的诀窍是，要意识到，完成对其调用后将存在两个进程，且每个进程都会从 fork()的返回处继续执行。这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段、数据段以及堆段拷贝。子进程的栈、数据以及栈段开始时是对父进程内存相应各部分的完全复制。执行 fork()之后，每个进程均可修改各自的栈数据、以及堆段中的变量，而并<strong>不影响另一进程</strong>。</p><p>程序代码则可通过 fork()的返回值来区分父、子进程。在父进程中，fork()将返回新创建子进程的进程 ID。鉴于父进程可能需要创建，进而追踪多个子进程（通过 wait()或类似方法），这种安排还是很实用的。而 fork()在子进程中则返回 0。如有必要，子进程可调用 getpid()以获取自身的进程 ID，调用 getppid()以获取父进程 ID。</p><p>当无法创建子进程时，fork()将返回-1。失败的原因可能在于，进程数量要么超出了系统针对此真实用户（real user ID）在进程数量上所施加的限制，要么是触及允许该系统创建的最大进程数这一系统级上限。</p><p>调用 fork()时，有时会采用如下习惯用语：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid;</span><br><span class="line"><span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="comment">//处理错误</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">//子进程行为</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//父进程行为</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 fork()之后，系统将率先“垂青”于哪个进程（即调度其使用 CPU），是无法确定的，意识到这一点极为重要。在设计拙劣的程序中，这种不确定性可能会导致所谓“竞争条件（race condition）”的错误</p><h3 id="vfork-函数"><a href="#vfork-函数" class="headerlink" title="vfork()函数"></a>vfork()函数</h3><p>在早期的 BSD 实现中，fork()会对父进程的数据段、堆和栈施行严格的复制。如前所述，这是一种浪费，尤其是在调用 fork()后立即执行 exec()的情况下。出于这一原因，BSD 的后期版本引入了 vfork()系统调用，尽管其运作含义稍微有些不同（实则有些怪异），但效率要远高于 BSD fork()。现代 UNIX 采用写时复制技术来实现 fork()，其效率较之于早期的 fork()实现要高出许多，进而将对 vfork()的需求剔除殆尽。虽然如此，Linux（如同许多其他的 UNIX 实现一样）还是提供了具有 BSD 语义的 vfork()系统调用，以期为程序提供尽可能快的 fork 功能。不过，鉴于 vfork()的怪异语义可能会导致一些难以察觉的程序缺陷（bug），除非能给性能带来重大提升（这种情况发生的概率极小），否则应当尽量避免使用这一调用。</p><p>类似于 fork()，vfork()可以为调用进程创建一个新的子进程。然而，vfork()是为子进程立即执行 exec()的程序而专门设计的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pid t <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在父进程中：成功时返回子进程的进程 ID，失败时返回 -1；</span></span><br><span class="line"><span class="comment">//在成功创建的子进程中：始终返回 0。</span></span><br></pre></td></tr></table></figure><p>vfork()因为如下两个特性而更具效率，这也是其与 fork()的区别所在。</p><ul><li>无需为子进程复制虚拟内存页或页表。相反，子进程共享父进程的内存，直至其成功执行了 exec()或是调用_exit()退出。</li><li>在子进程调用 exec()或_exit()之前，将暂停执行父进程。</li></ul><h3 id="exit-函数"><a href="#exit-函数" class="headerlink" title="_exit()函数"></a>_exit()函数</h3><p>通常，进程有两种终止方式。其一为异常（abnormal）终止，由对一信号的接收而引发，该信号的默认动作为终止当前进程，可能产生核心转储（core dump）。此外，进程可使用_exit()系统调用正常（normally）终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd,h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p>_exit()的 status 参数定义了进程的终止状态（termination status），父进程可调用 wait()以获取该状态。虽然将其定义为 int 类型，但仅有低 8 位可为父进程所用。按照惯例，终止状态为 0 表示进程“功成身退”，而非 0 值则表示进程因异常而退出。对非 0 返回值的解释则并无定例；不同的应用程序自成一派，并会在文档中加以描述。SUSv3 规定有两个常量：EXIT_SUCCESS(0)和 EXIT_FAILURE(1)，本书中大部分程序就采用了这一约定。</p><p>调用_exit()的程序总会成功终止（即，_exit()从不返回）。</p><h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">pid t <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *stalus)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回已终止子进程的进程 ID，或者在出错时返回 -1。</span></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Linux系统编程学习</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.wikunkun.asia/posts/115b96c9.html">https://www.wikunkun.asia/posts/115b96c9.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Lambda</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-01-13</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-02-13</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Linux</a><a class="post-meta__tags" href="/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>远程开发</a><a class="post-meta__tags" href="/tags/C-C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C/C++</a><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>系统调用</a></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c5c01ec0.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117154810386.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux上安装conan 并且与CLion与cmake结合使用</div></div></a></div><div class="next-post pull-right"><a href="/posts/2338738d.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117160139542.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux上的vcpkg安装</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/18ae5e5d.html" title="VSCode连接Linux服务器进行远程C++开发"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117161143861.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-04-27</div><div class="title">VSCode连接Linux服务器进行远程C++开发</div></div></a></div><div><a href="/posts/2338738d.html" title="Linux上的vcpkg安装"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117160139542.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-02-13</div><div class="title">Linux上的vcpkg安装</div></div></a></div><div><a href="/posts/c5c01ec0.html" title="Linux上安装conan 并且与CLion与cmake结合使用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117154810386.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-02-13</div><div class="title">Linux上安装conan 并且与CLion与cmake结合使用</div></div></a></div><div><a href="/posts/29c15ce3.html" title="安装Docker"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117160726430.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-05-02</div><div class="title">安装Docker</div></div></a></div><div><a href="/posts/25452eac.html" title="安装Linux虚拟机"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117160531023.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-02-13</div><div class="title">安装Linux虚拟机</div></div></a></div><div><a href="/posts/20241127.html" title="Ubuntu上安装V2rayA"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250313143733767.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-02-13</div><div class="title">Ubuntu上安装V2rayA</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:700">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">常用头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E5%BD%95"><span class="toc-text">系统数据类型选录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-I-O%EF%BC%9A%E9%80%9A%E7%94%A8%E7%9A%84-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-text">文件 I&#x2F;O：通用的 I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8-I-O"><span class="toc-text">通用 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open-%E5%87%BD%E6%95%B0"><span class="toc-text">open()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#creat-%E5%87%BD%E6%95%B0"><span class="toc-text">creat()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-%E5%87%BD%E6%95%B0"><span class="toc-text">read()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-%E5%87%BD%E6%95%B0"><span class="toc-text">write()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-%E5%87%BD%E6%95%B0"><span class="toc-text">close()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lseek-%E5%87%BD%E6%95%B0"><span class="toc-text">lseek()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E6%96%87%E4%BB%B6-I-O"><span class="toc-text">深入探究文件 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl-%E5%87%BD%E6%95%B0"><span class="toc-text">fcntl()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup-%E5%87%BD%E6%95%B0"><span class="toc-text">dup()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup2-%E5%87%BD%E6%95%B0"><span class="toc-text">dup2()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup3-%E5%87%BD%E6%95%B0"><span class="toc-text">dup3()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pread-%E5%87%BD%E6%95%B0"><span class="toc-text">pread()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwrite-%E5%87%BD%E6%95%B0"><span class="toc-text">pwrite()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readv-%E5%87%BD%E6%95%B0"><span class="toc-text">readv()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#writev-%E5%87%BD%E6%95%B0"><span class="toc-text">writev()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#preadv-%E5%87%BD%E6%95%B0"><span class="toc-text">preadv()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwritev-%E5%87%BD%E6%95%B0"><span class="toc-text">pwritev()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#truncate-%E5%87%BD%E6%95%B0"><span class="toc-text">truncate() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ftruncate-%E5%87%BD%E6%95%B0"><span class="toc-text">ftruncate()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkstemp-%E5%87%BD%E6%95%B0"><span class="toc-text">mkstemp()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tmpfile-%E5%87%BD%E6%95%B0"><span class="toc-text">tmpfile()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getpid-%E5%87%BD%E6%95%B0"><span class="toc-text">getpid()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getppid-%E5%87%BD%E6%95%B0"><span class="toc-text">getppid()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getenv-%E5%87%BD%E6%95%B0"><span class="toc-text">getenv()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putenv-%E5%87%BD%E6%95%B0"><span class="toc-text">putenv()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setenv-%E5%87%BD%E6%95%B0"><span class="toc-text">setenv()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">进程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-%E5%87%BD%E6%95%B0"><span class="toc-text">fork()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfork-%E5%87%BD%E6%95%B0"><span class="toc-text">vfork()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit-%E5%87%BD%E6%95%B0"><span class="toc-text">_exit()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%87%BD%E6%95%B0"><span class="toc-text">wait()函数</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color:transparent"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🌈</p><div class="bg-ad"><div>不论你在什么时候开始,重要的是开始之后不要停止;无论你在什么时间结束,重要的是结束之后就不要后悔</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/box/gallery/">我的画廊</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/site/echarts/">文章统计</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链🤝</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/img/avatar.webp" alt=""></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://blog.eurkon.com/" title="Eurkon"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/eurkon-cdn/hexo/images/user/avatar.jpg" alt=""></a></div></div></div></div><div class="copyright"><span><b>&copy;2024-2025</b></span><span><b>&nbsp;&nbsp;By Lambda</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/Frame-Hexo-blue.svg" alt=""></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/Theme-Butterfly-6513df.svg" alt=""></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://lambda-image-1.pages.dev/Source-Github-d021d6.svg" alt=""></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-music"><a class="rightMenu-item" href="javascript:anzhiyu.musicSkipBack();"><i class="fa fa-step-backward"></i><span>上一首</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicToggle();"><i class="fa fa-play"></i><span>暂停/播放</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicSkipForward();"><i class="fa fa-step-forward"></i><span>下一首</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading()),setTimeout((function(){preloader.endLoading()}),5e3),document.getElementById("loading-box").addEventListener("click",(()=>{preloader.endLoading()}))</script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.2},options:{renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),s=document.createTextNode("");e.parentNode.replaceChild(s,e),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},t.math.push(n)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container:not([display])").forEach((t=>{const e=t.parentNode;"li"===e.nodeName.toLowerCase()?e.parentNode.classList.add("has-jax"):e.classList.add("has-jax")}))},"",!1]}}};const t=document.createElement("script");t.src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://lambda-twikoo.netlify.app/.netlify/functions/twikoo",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn.jsdelivr.net/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="//at.alicdn.com/t/c/font_4760581_ystn3ruh4p.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script src="https://cdn.jsdelivr.net/npm/winbox"></script><script defer src="/js/lambda.js"></script><script charset="UTF-8" id="LA_COLLECT" src="https://sdk.51.la/js-sdk-pro.min.js"></script><script src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script>LA.init({id:"3KQqB8IddjwJUGKv",ck:"3KQqB8IddjwJUGKv"})</script><script>(new LingQue.Monitor).init({id:"3KQqB8IddjwJUGKv",sendSuspicious:!0})</script><script id="click-show-text" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-show-text.min.js" data-mobile="false" data-text="🏡 结庐在人境,🌾 而无车马喧,🌱 采菊东篱下,🎐 悠然见南山" data-fontsize="15px" data-random="false" async></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="contact-info"><div class="option"><i class="fas fa-rocket"></i><div class="bloktop"></div><div class="text button"><button class="btn" type="button" onclick="randomPost()">随便逛逛</button><div class="strip"></div></div></div><div class="option"><i class="fas fa-music"></i><div class="blokbottom"></div><div class="text aplayertext"><div class="music-hover" id="nav-music-hoverTips"><meting-js class="no-destroy" id="12893290734" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-theme)" data-lrctype="0" order="random"></meting-js></div><div class="strip"></div></div></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.wikunkun.asia/categories/后端开发/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 小Lの后端开发笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.wikunkun.asia/categories/Linux平台开发/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 小LのLinux平台开发笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.wikunkun.asia/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#e9e9e9;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ebcd8e7e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117160340119.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ebcd8e7e.html&quot;);" href="javascript:void(0);" alt="">MarkDown中的数学符号</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ebcd8e7e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/20241127.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250313143733767.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/20241127.html&quot;);" href="javascript:void(0);" alt="">Ubuntu上安装V2rayA</a><div class="blog-slider__text">本文记录了博主目前用Docker部署过的全部内容</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/20241127.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6e4eaf21.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117161242775.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6e4eaf21.html&quot;);" href="javascript:void(0);" alt="">Docker常用工具的安装方法</a><div class="blog-slider__text">本文记录了博主目前用Docker部署过的全部内容</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6e4eaf21.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lambda-image-1.pages.dev/20250117160933246.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("gitZone").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("gitZone")&&"/site/census/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("/api?null",["#d9e0df","#c6e0dc","#a8dcd4","#9adcd2","#89ded1","#77e0d0","#5fdecb","#47dcc6","#39dcc3","#1fdabe","#00dab9"],"null"))</script></body></html>